---
description: 
globs: 
alwaysApply: false
---
# Frontend Clean Code & High-Quality Development Guidelines (Flutter Focus)

아래 가이드는 상위 1% 시니어 개발자의 노하우를 바탕으로, 고품질 프론트엔드(특히 Flutter) 애플리케이션 개발을 위한 핵심 원칙과 실천 방법을 정리했습니다.

---

## 1. 코드 구조 & 가독성 (Structure & Readability)

1.  **단일 책임 원칙 (SRP):**
    * 각 파일, 클래스, 위젯(Widget), 함수는 **하나의 명확한 역할**(예: 상태 관리, UI 렌더링, 특정 로직 처리)만 담당하도록 설계합니다.
    * 로직이 혼재된 위젯은 역할에 따라 분리 (예: Presentational vs Container 위젯 패턴 고려).
    * SOLID 원칙 전반(OCP, LSP, ISP, DIP)을 함께 고려하여 유연하고 유지보수하기 쉬운 구조를 지향합니다.
2.  **직관적인 폴더 및 파일 구조:**
    * **기능(Feature) 기반** 또는 **레이어(Layer)** 기반(예: `features/`, `shared/`, `core/` 또는 `ui/`, `domain/`, `data/`)으로 폴더 구조를 명확히 하여 탐색과 이해를 돕습니다.
    * 파일명은 위젯, 스크린, 서비스, 모델 등의 **역할과 내용**을 명확히 드러내도록 작성합니다 (예: `user_profile_card.dart`, `auth_view_model.dart`).
3.  **간결한 위젯과 함수:**
    * 위젯의 `build` 메소드와 일반 함수는 간결하게 유지합니다 (가이드라인: **25~30줄** 이내).
    * 복잡한 `build` 메소드는 하위 위젯으로 분리하고, 긴 함수는 로직 단위로 분할합니다.

---

## 2. 명명 규칙 & 스타일 (Naming & Style)

1.  **의도가 드러나는 명칭:**
    * 변수, 함수, 클래스, 위젯명은 해당 대상의 **역할과 목적**이 명확히 드러나도록 작성합니다 (예: `isLoading`, `WorkspaceUserData`, `UserProfileScreen`, `calculateTotalPrice`).
    * 축약어(명확히 통용되는 경우 제외)를 지양하고 검색 가능한 이름을 사용합니다.
2.  **일관된 컨벤션 (Dart/Flutter Style):**
    * Dart 공식 스타일 가이드(Effective Dart)를 준수합니다 (CamelCase, PascalCase 등).
    * 클래스/타입/Enum/Mixin/Extension은 `UpperCamelCase`, 변수/함수/메서드/파라미터는 `lowerCamelCase`, 파일명/디렉토리명은 `snake_case`를 사용합니다.
3.  **자동화된 포매터 & 린터:**
    * `dart format`과 `analysis_options.yaml` 설정을 통한 **정적 분석(Linter)**을 적극 활용하여 코드 스타일과 잠재적 오류를 자동으로 관리합니다.
    * 팀/프로젝트 전체에 동일한 규칙을 적용하여 일관성을 유지합니다.

---

## 3. DRY 원칙 & 재사용성 (Don't Repeat Yourself & Reusability)

1.  **중복 로직 및 위젯 제거:**
    * 반복되는 로직은 즉시 공통 함수/클래스/Mixin(`utils/`, `mixins/`)으로 추출합니다.
    * 여러 곳에서 사용되는 UI 패턴은 **재사용 가능한 위젯**(`shared/widgets/`)으로 분리합니다.
    * 매직 넘버/문자열은 상수(`constants/`) 또는 Enum으로 정의하여 공유합니다.
2.  **재사용 가능한 컴포넌트 설계:**
    * 공통 위젯은 특정 화면에 종속되지 않도록 **범용성**을 고려하여 설계하고, 필요한 속성(Props)을 명확히 정의합니다.
    * 유틸리티 함수 등도 특정 기능에 국한되지 않도록 일반화하여 작성합니다.

---

## 4. 상태 관리 & 데이터 흐름 (State Management & Data Flow)

1.  **적절한 상태 관리 전략:**
    * 애플리케이션의 복잡도에 맞는 상태 관리 솔루션(Riverpod, Provider, Bloc 등)을 선택하고 일관되게 사용합니다.
    * **상태의 범위**를 명확히 합니다 (위젯 로컬 상태 vs 전역 상태). 불필요한 상태 공유를 지양합니다.
    * UI 상태와 비즈니스/데이터 상태를 분리하여 관리하는 것을 고려합니다 (예: ViewModel, StateNotifier 패턴).
2.  **단방향 데이터 흐름:**
    * 상태 변경은 예측 가능한 방식으로 이루어지도록 데이터 흐름을 명확히 합니다 (예: UI 이벤트 -> 로직 처리 -> 상태 변경 -> UI 업데이트).
3.  **불변성 유지:**
    * 상태 객체(State Object)는 가능한 **불변(Immutable)**하게 관리합니다. 상태 변경 시 원본을 직접 수정하지 않고, 새로운 객체를 생성하여 업데이트합니다 (예: `copyWith` 메서드 활용).

---

## 5. 성능 최적화 (Performance Optimization)

1.  **효율적인 위젯 빌드:**
    * `build` 메소드는 가볍고 빠르게 유지합니다. 무거운 연산이나 API 호출을 `build` 내에서 직접 수행하지 않습니다.
    * `const` 키워드를 최대한 활용하여 불필요한 위젯 재생성을 방지합니다.
    * 상태 변경 시 꼭 필요한 부분만 리빌드되도록 위젯을 적절히 분리하고, `select` (Provider/Riverpod) 등을 활용합니다.
2.  **렌더링 성능:**
    * 복잡한 레이아웃이나 대규모 목록(`ListView`, `GridView`) 렌더링 시 성능 저하 요인을 파악하고 최적화합니다 (예: `ListView.builder`, key 활용).
    * 불필요한 애니메이션이나 시각 효과 사용을 지양하고, 최적화된 방식으로 구현합니다.
3.  **이미지 및 에셋 최적화:**
    * 이미지 크기와 형식을 최적화하고, `CachedNetworkImage` 등을 활용하여 로딩 성능을 개선합니다.
    * 필요한 에셋만 번들에 포함되도록 관리합니다.
4.  **네트워크 요청 최적화:**
    * 불필요하거나 중복되는 API 호출을 최소화합니다 (캐싱 전략 활용).
    * 화면에 필요한 데이터만 요청하고, 로딩 상태를 명확히 표시합니다.

---

## 6. 코드 복잡도 & 유지보수 (Complexity & Maintainability)

1.  **낮은 순환 복잡도:**
    * 함수/메서드 내 분기(if, switch, for 등)를 줄여 복잡도를 낮게 유지합니다 (가이드라인: **10 미만**).
    * 복잡도가 높은 함수는 로직 분할 또는 패턴(예: Strategy Pattern) 적용을 고려합니다.
2.  **간결한 조건문:**
    * 중첩된 `if-else` 문은 2단계를 넘지 않도록 하고, Guard Clauses (조건 불일치 시 빠른 반환)를 활용하여 가독성을 높입니다.
    * 다형성(Polymorphism)을 활용하여 조건 분기 자체를 줄이는 설계를 고려합니다.
3.  **의미 있는 상수 사용:**
    * 코드 내 매직 넘버나 하드코딩된 문자열은 의미 있는 이름을 가진 상수나 Enum으로 대체합니다.

---

## 7. 테스트 전략 & 품질 확보 (Testing & Quality Assurance)

1.  **위젯/로직 단위 테스트:**
    * 핵심 로직(ViewModel, UseCase, Utils)과 상태 변화에 따른 위젯의 동작을 **단위 테스트(Unit Test)** 및 **위젯 테스트(Widget Test)**로 검증합니다. (목표 커버리지: 80-90% 이상)
2.  **통합 테스트:**
    * 화면 흐름, 상태 관리와 API 연동 등 여러 모듈이 함께 동작하는 핵심 경로를 **통합 테스트(Integration Test)**로 검증합니다.
3.  **자동화된 테스트 실행:**
    * CI/CD 파이프라인에 테스트 자동화를 구축하여 코드 변경 시 회귀 오류를 조기에 발견합니다.

---

## 8. 주석과 문서화 (Comments & Documentation)

1.  **자기 설명적인 코드:**
    * 명확한 네이밍과 구조를 통해 코드가 스스로 설명하도록 작성하는 것을 우선합니다.
2.  **필요 최소한의 주석:**
    * 복잡한 로직의 **의도**(Why)나 특정 결정의 **배경** 설명이 필요할 때 간결하게 작성합니다.
    * `// FIXME:` 또는 `// TODO:` 주석은 이슈 트래킹 시스템과 연동하거나 주기적으로 관리합니다.
3.  **Dart Doc 활용:**
    * Public API (클래스, 메서드, 함수)에는 Dart Doc 주석 (`///`)을 작성하여 파라미터, 반환값, 사용법 등을 명확히 합니다.

---

## 9. 접근성 (Accessibility - a11y)

1.  **시맨틱 위젯 사용:**
    * 가능한 의미에 맞는 위젯(예: `Button` 대신 `ElevatedButton`, `GestureDetector` 대신 시맨틱 위젯 사용)을 사용합니다.
2.  **스크린 리더 지원:**
    * `Semantics` 위젯을 활용하여 스크린 리더 사용자에게 필요한 정보(label, hint 등)를 제공합니다.
    * 터치 영역 크기(`minTapTargetSize`)를 충분히 확보합니다.
3.  **색상 대비 및 가독성:**
    * 텍스트와 배경 간 충분한 명도 대비를 확보하고, 사용자가 폰트 크기를 조절할 수 있도록 지원합니다.
4.  **키보드 네비게이션:**
    * 필요한 경우 포커스 이동 순서와 상호작용을 지원합니다.

---

## 10. 리팩토링 & 지속적 개선 (Refactoring & Continuous Improvement)

1.  **점진적 리팩토링:**
    * 기능 개발 시 관련된 기존 코드를 함께 개선하는 것을 습관화합니다 (보이스카우트 규칙).
    * 주기적으로 코드 스멜(Code Smell)을 찾아 제거하고 구조를 개선합니다.
2.  **기술 부채 관리:**
    * 임시방편으로 작성된 코드는 반드시 기록(`// TODO:`, 이슈 등록)하고 계획적으로 개선합니다.
3.  **정적 분석 도구 활용:**
    * Linter 규칙 위반, 미사용 코드, 복잡도 등을 주기적으로 점검하고 개선합니다.

---

## 결론

* **코드는 명확하고 간결하게, 단일 책임을 갖는 구조**로 작성합니다. (가독성, 유지보수성)
* **DRY 원칙, 재사용성, 적절한 상태 관리**를 통해 중복을 최소화하고 관리하기 쉬운 코드를 만듭니다. (효율성, 확장성)
* **성능, 접근성**을 고려하여 모든 사용자에게 좋은 경험을 제공합니다. (품질)
* **테스트와 린팅**으로 결함을 조기에 발견하고, **지속적 리팩토링**으로 코드 품질을 유지/개선합니다. (안정성)

이 가이드라인을 팀 내 컨벤션과 도구(정적 분석, CI/CD, 코드 리뷰 등)와 함께 꾸준히 적용하고 개선해 나간다면, 장기적으로 안정적이고 확장 가능한 고품질 프론트엔드 애플리케이션을 구축할 수 있을 것입니다.